This is the third post in the series about creating a custom select menu. The first post outlined the issue and the second discussed the special challenges associated with keeping track of state changes. In this post, I will discuss my approach for keeping track of view changes.

Keeping track of view changes can be done in different ways. It's possible to do so using simple vanilla JS or using an external framework (like React). I created demos using both. In the vanilla JS demo, I used the following approach for DOM updates. For each select menu element and option element, I created a "node" object. This object creates a dom element and has methods for performing various actions on it (e.g. adding a class, setting a data property, etc.). The node object allows allows the author to create what I call "observed variable attributes." For example, the author can create a class variable attribute. This object allows the author to create a "valueCalculator" method, which specifies how function used to determine the value of the class attribute. The node object can subscribe to store updates, and when the state updates, the "valueCalculator" function is called to determine a new value for the attribute. If the new value is different from the old value, then the DOM element's class list is updated. The author does not need to specify how the dom changes are made. This is an implementation detail in the Node class. All the author has to do is specify the value calculator. If an animation is supposed to happen, the author can also specify and "animatingCalculator." If the value needs updating, the animatingCalculator function is executed. If it returns true, then the DOM change is made and it waits for an animation to complete.

Using this "observed variable attribute" pattern is my attempt to create more declarative view changes. All the author has to do is specified when the class should be applicable. The implementation details of the DOM changes are abstracted away.

The animation challenges are handled in the following away. The "node" class has an animate method that takes a function that is responsible for the animation and returns a promise. When the animate function is execute, a callback is executed to reflect that the animation is started. Next, an 'animationend' listener is added to the dom node and the animation function is executed. The listener listens for an animationend end event to occur, and when it does, the listener removes itself from the dom node, and resolves the promise. A callback is then executed to notify of the end of the animation.

I decided that I wanted to create versions of the demo in both vanilla JS and React. When I started out, I had anticipated that there would be big differences between the two versions, but in fact, the differences were relatively small. In React, you can't specify that a certain view update involves an animation. To make the animation work, you have to create external stores to keep track of the state. View components can then subscribe to state updates and update their view states accordingly. Thus, React can't let you get by without the relatively heavy store framework. In react, the state values are analogous to the variable attributes. When the state values are updated, React handles the details of changing the DOM. Thus, React doesn't really buy you that much in this case. 
