In the previous post, I outlined the two challenges of creating a custom select menu with animations: one that pertains to the state and one that pertains to the view. In this post, I'll talk about how I overcame the state-related challenges.

In various projects, I've found that in managing the state, the following design system can be very useful (this is similar to and inspired by redux). In this system, a "store" is a JavasScript object that contains and manages a state object. The store has certain methods called "actions" which update the state is specific ways. The store also allows view components to subscribe to state updates. When the state changes, the view listeners are notified of these changes and they update accordingly.

To meet the state-related challenges of the select menu project, I made a couple modifications in this system. First, I modified the notification system so that all notifications are asyncronous. This allows for view updates to include animations. The view update is not complete until the animation has completed. Second, I modified the subscription system so that when a listener subscribes to model updates, it has to include both a callback and an identifier. It is then possible to specify for each action, what order the listeners should be notified. In the case of an "optionClick" action, the 'option.updateSelectedOption' listener should be notified first, the 'select.openState' listener should be notified second (which is done asyncronously) and the 'emitter.messages' listener should be notified third. If an action does not have a specified update order, then the listeners are notified in the order they subscribed.

The incorporation of animations in the view update meant that I needed a separate store to keep track of changes in the view updating process. Thus, in addition to a global store, I also created a "view store." The view store contained three state properties: 1) a flag that is set when an animation is in progress, 2) a flag for if the select menu controls are enabled, and 3) a flag for if animations are enabled.

So when the view is updated and the animation is run toggling the select menu open state, an action in the view store store is executed specifying that an animation is in progress. When this happens, the view is updated and a message is broadcasted notifying any public listeners that an animation is in progress. When the animation is completed, the view is updated again and a message is broadcasted that the animation has ended.

I decided that it made sense to have both a global store and a view store. I did not want to combine them because I thought it was important to separate the global business logic (the model) and the view business logic. Furthermore, I wanted updates from global state changes to be able to modify the view state, not the global state. If updates from the global state further modified the global state, then this could potentially create a mess [explain this better].
