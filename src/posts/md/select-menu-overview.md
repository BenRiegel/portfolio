The PGE project [insert link] that I worked on incorporates a select menu that controls which elements are included in the web map. Select menus are one of those HTML elements that are hard to style because their appearance is, to a large extent, controlled by the device's operating system. For this project, I wanted the select menu to adhere to the design patters of the other web map widgits (e.g. the zoom wigit, the pop-up menu). I also wanted the select menu to do a cool animation when opening and closing, which is not possible with native select menus. Therefore, I decided I would try to create a custom select menu.

In creating the select menu, I first attempted to identify certain features that needed to be implemented. It needed to be allow users to listen for events (e.g. a new select menu value). It needed to allow users to disable or enable it (the map is zooming in or out, we want to disable all the controls until the animation is completed). It needed to allow users to forcibly close it, if necessary.

The next step in creating a select menu is to identify the internal states that need to be tracked. When these are updated, the user interface needs to be updated as well. These include the options that are currently in the select menu, which one is selected, the value that is selected, and the open vs. closed state.

Creating a syncronous (i.e. one with no animations) is not terribly challenging. When a user clicks an option, an event is triggered. The state is updated in the following way: the current selected option is updated with the clicked option, the current selected value is updated with the value of the clicked option, and the open state of the select menu is toggled. When the state updates, the user interface is notified and the attributes of the DOM elements are updated. Furthermore, if the selected option value has changed, then a message is broadcasted to any public listeners.

Creating a select menu with animations creates some interesting challenges. When the view updates to reflect state changes, this happens asyncronously. This means that when the view is notified that the state has changed, things have to happen in a particular order. Suppose that the select menu is currently open. If the user clicks on a new option, things have to happen in the following order: 1) the current selected option has to be updated (i.e. the old selected option unchecked and the new one checked); 2) the open state has to toggle (which is done asyncronously); and 3) the public is notified of the selected value change.

Furthermore, creating a select menu with animations creates some additional challenges with managing the view. In particular, the select menu has to keep track of the view update state. If the open state of the select menu is in the process of changing from open to closed or vice versa, then we do not want the user to be able to click the select menu again. In other words, we want the select menu to disable its own controls while the animation is in progress and to enable it again when the animation has completed. Furthermore, we want the select menu to broadcast when an animation has started and completed.

In sum, when creating a select menu with animations, two special challenges arise: keeping track of the state and updating the view. In the next post, I'll discuss how to overcome the problem of keeping track of state. In the third post, I'll discuss how to overcome the challenges of updating the view with asyncronous updates. 
