# Select Menu Project, Overview

The select menu is one of those HTML elements that is hard to style because much of its appearance is controlled by a device's operating system. If you use the default <select> element, you're usually stuck with something that's boring and doesn't look good. For a previous project [**insert link**], I created a custom select menu that animates the opening and closing of the menu. Recently, I decided to go back and revisit the code for the select menu. It decided to implement two versions, one using vanilla JavaScript (**demo and code**) and another using React (**demo and code**).

Creating a custom, animated select menu is a fun project because it involves an interesting challenge - managing asyncronous view updates. In this blog post, I'll provide an overview of this challenge, and in my next post I'll discuss how I overcame it. Finally, in a third post, I'll discuss the some differences between the vanilla JS version and the React version.

The select menu that I created performs an animation when it opens and closes. On opening, the select menu expands and the unselected options fade in so that all the options are visible. On closing, it does the opposite: the unselected options fade out and the select menu contracts so that only the selected option is visible. Besides this visual feature, I needed the widget to do certain things. I wanted the select menu to notify listeners when important events occur, such as the selection of a new selected value by the user. I also wanted it to allow controllers to enable/disable the animation and enable/disable the input controls.

Any select menu needs to keep track of certain internal states. These include: 1) the set of options that are currently loaded in the select menu, 2) the option that is currently selected, and 3) the open vs closed state of the menu. When the user clicks on an option, these states need to be updated. If the select menu is open and the user clicks on a new option, the selected option state is updated and the open state is toggled from 'open' to 'closed.' When the state is changed, the user-interface needs to be updated to reflect these changes. The previous selected option needs to be unselected, the new selected option needs to be selected, and the select menu needs to closed. Moreover, any event listeners need to be notified that there is a new selected option value.

Updating various components when the application state changes is a challenging aspect of app design. Creating a select menu with animations makes this even more challenging. Let's consider what happens when the user clicks on an option. The state is changed, and then the options are notified that a new one is selected. The old selected option becomes unselected, and the new selected option becomes selected. Next, the select menu needs to toggle asyncronously from open to closed. Finally, listeners are notified of the state change. Thus, when we have animations in a select menu, the update of the user interface happen asyncronously and in a particular order. The selected options are updated first, then the select menu closes, and then the listeners are notified of a new selected option.

But that's not all. When the animation starts, we don't want the user to be able to click the select menu again. That would create some weird, undesirable visual effects. Thus, we want to disable the click listener while the animation starts, and enable it again when the animation finishes. Furthermore, we want the select menu to broadcast when an animation has started and completed.

In sum, creating an animated select menu creates state management more complicated in two ways. First, components have to be updated asyncronously and in a particular order. And second, an asyncronous view update itself has a state component that needs to be tracked: i.e. whether an animation is currently in progress or not. In the next post [**insert link**], I'll discuss the ways that I addressed these two challenges.
